{"version":3,"file":"735.95ccfca9efbfca5f5f36.js","mappings":"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","sources":["webpack://ctFrontend/./static/js/frontend/parallax/ios-inner-height.js","webpack://ctFrontend/./static/js/frontend/parallax/rellax.js","webpack://ctFrontend/./static/js/frontend/parallax/register-listener.js"],"sourcesContent":["'use strict'\n\nfunction isIpad() {\n\tconst ua = window.navigator.userAgent\n\n\tif (ua.indexOf('iPad') > -1) {\n\t\treturn true\n\t}\n\n\tif (ua.indexOf('Macintosh') > -1) {\n\t\ttry {\n\t\t\tdocument.createEvent('TouchEvent')\n\t\t\treturn true\n\t\t} catch (e) {}\n\t}\n\n\treturn false\n}\n\n/**\n * @module ios-inner-height\n *\n * @description Get proper window.innerHeight from iOS devices,\n * excluding URL control and menu bar.\n *\n * @return {function} Callable function to retrieve the\n * cached `window.innerHeight` measurement, specific to the\n * device's current orientation.\n */\nmodule.exports = (function () {\n\t// Avoid errors when globals are undefined (CI, etc)\n\t// https://github.com/tylerjpeterson/ios-inner-height/pull/7\n\tif (typeof window === 'undefined' || typeof navigator === 'undefined') {\n\t\treturn function () {\n\t\t\treturn 0\n\t\t}\n\t}\n\n\t// Non-iOS browsers return window.innerHeight per usual.\n\t// No caching here since browsers can be resized, and setting\n\t// up resize-triggered cache invalidation is not in scope.\n\t/* istanbul ignore if  */\n\tif (!navigator.userAgent.match(/iphone|ipod|ipad/i) && !isIpad()) {\n\t\t/**\n\t\t * Avoids conditional logic in the implementation\n\t\t * @return {number} - window's innerHeight measurement in pixels\n\t\t */\n\t\treturn function () {\n\t\t\treturn window.innerHeight\n\t\t}\n\t}\n\n\t// Store initial orientation\n\tvar axis = Math.abs(window.orientation)\n\t// And hoist cached dimensions\n\tvar dims = { w: 0, h: 0 }\n\n\t/**\n\t * Creates an element with a height of 100vh since iOS accurately\n\t * reports vp height (but not window.innerHeight). Then destroy it.\n\t */\n\tvar createRuler = function () {\n\t\tvar ruler = document.createElement('div')\n\n\t\truler.style.position = 'fixed'\n\t\truler.style.height = '100vh'\n\t\truler.style.width = 0\n\t\truler.style.top = 0\n\n\t\tdocument.documentElement.appendChild(ruler)\n\n\t\t// Set cache conscientious of device orientation\n\t\tdims.w = axis === 90 ? ruler.offsetHeight : window.innerWidth\n\t\tdims.h = axis === 90 ? window.innerWidth : ruler.offsetHeight\n\n\t\t// Clean up after ourselves\n\t\tdocument.documentElement.removeChild(ruler)\n\t\truler = null\n\t}\n\n\t// Measure once\n\tcreateRuler()\n\n\t/**\n\t * Returns window's cached innerHeight measurement\n\t * based on viewport height and device orientation\n\t * @return {number} - window's innerHeight measurement in pixels\n\t */\n\treturn function () {\n\t\tif (Math.abs(window.orientation) !== 90) {\n\t\t\treturn dims.h\n\t\t}\n\n\t\treturn dims.w\n\t}\n})()\n","// ------------------------------------------\n// Rellax.js - v1.0.0\n// Buttery smooth parallax library\n// Copyright (c) 2016 Moe Amaya (@moeamaya)\n// MIT license\n//\n// Thanks to Paraxify.js and Jaime Cabllero\n// for parallax concepts\n// ------------------------------------------\n\nimport { getCurrentScreen } from '../helpers/current-screen'\nimport innerHeight from './ios-inner-height'\n\n// Ahh a pure function, gets new transform value\n// based on scrollPostion and speed\n// Allow for decimal pixel values\nconst updatePosition = (percentage, speed) => speed * (100 * (1 - percentage))\n\n// We want to cache the parallax blocks'\n// values: base, top, height, speed\n// el: is dom object, return: el cache values\nconst createBlock = ({\n\tel = null,\n\tspeed = null,\n\tfitInsideContainer = null,\n\tisVisible = false,\n\tshouldSetHeightToIncrease = true,\n\tparallaxBehavior = 'desktop:tablet:mobile',\n}) => {\n\t// Optional individual block speed as data attr, otherwise global speed\n\t// Check if has percentage attr, and limit speed to 5, else limit it to 10\n\t// The function is named clamp\n\tspeed = speed <= -5 ? -5 : speed >= 5 ? 5 : speed\n\n\t// We need to guess the position the background will be, when the section\n\t// will reach the top of the viewport. This calculation will be based on the\n\t// speed for sure\n\tif (fitInsideContainer && shouldSetHeightToIncrease) {\n\t\tlet heightWeWantToIncrease = 0\n\n\t\tif (speed > 0) {\n\t\t\theightWeWantToIncrease = updatePosition(0.5, speed)\n\t\t} else {\n\t\t\theightWeWantToIncrease =\n\t\t\t\tupdatePosition(\n\t\t\t\t\tinnerHeight() /\n\t\t\t\t\t\t(fitInsideContainer.clientHeight + innerHeight()),\n\t\t\t\t\tspeed\n\t\t\t\t) - updatePosition(0.5, speed)\n\t\t}\n\n\t\theightWeWantToIncrease = Math.abs(heightWeWantToIncrease) * 2\n\n\t\tel.parentNode.style.height = !isVisible\n\t\t\t? '100%'\n\t\t\t: `calc(100% + ${heightWeWantToIncrease}px)`\n\t}\n\n\t// initializing at scrollY = 0 (top of browser)\n\t// ensures elements are positioned based on HTML layout.\n\n\tlet { top, height } = nullifyTransforms(\n\t\tfitInsideContainer ? fitInsideContainer : el\n\t)\n\n\tvar blockTop = pageYOffset + top\n\n\treturn {\n\t\tparallaxBehavior,\n\t\tshouldSetHeightToIncrease,\n\t\tfitInsideContainer,\n\t\tel,\n\t\ttop: blockTop,\n\t\theight,\n\t\tspeed,\n\t\tisVisible,\n\t}\n}\n\nfunction elementInViewport(el) {\n\tvar rect = el.getBoundingClientRect()\n\n\treturn (\n\t\trect.bottom > -450 &&\n\t\trect.top - 450 <\n\t\t\t(innerHeight() ||\n\t\t\t\tdocument.documentElement\n\t\t\t\t\t.clientHeight) /* or $(window).height() */\n\t)\n}\n\nfunction nullifyTransforms(el) {\n\tif (!el) return null\n\n\t//add sanity checks and default values\n\n\tlet { top, left, right, width, height } = el.getBoundingClientRect()\n\n\tlet transformArr = window\n\t\t.getComputedStyle(el)\n\t\t.transform.split(/\\(|,|\\)/)\n\t\t.slice(1, -1)\n\t\t.map((v) => parseFloat(v))\n\n\tif (transformArr.length != 6) {\n\t\treturn el.getBoundingClientRect()\n\t}\n\n\t// 2D matrix\n\t// need some math to apply inverse of matrix\n\t// That is the matrix of the transformation of the element\n\tvar t = transformArr\n\tlet det = t[0] * t[3] - t[1] * t[2]\n\n\t/*if (transformArr.length > 6)*/\n\t//3D matrix\n\t//haven't done the calculation to apply inverse of 4x4 matrix\n\n\treturn {\n\t\twidth: width / t[0],\n\t\theight: height / t[3],\n\t\tleft: (left * t[3] - top * t[2] + t[2] * t[5] - t[4] * t[3]) / det,\n\t\tright: (right * t[3] - top * t[2] + t[2] * t[5] - t[4] * t[3]) / det,\n\t\ttop: (-left * t[1] + top * t[0] + t[4] * t[1] - t[0] * t[5]) / det,\n\t}\n}\n\nexport class Rellax {\n\tconstructor() {\n\t\tthis.blocks = []\n\t\tthis.oldPosY = false\n\n\t\tthis.intersectionObserver = new IntersectionObserver(\n\t\t\t(entries) => {\n\t\t\t\tentries.map(\n\t\t\t\t\t({ target: el, isIntersecting, intersectionRatio }) => {\n\t\t\t\t\t\tlet blocks = this.blocks.filter(\n\t\t\t\t\t\t\t({ fitInsideContainer, el: blockEl }) =>\n\t\t\t\t\t\t\t\tblockEl.closest('svg')\n\t\t\t\t\t\t\t\t\t? blockEl.closest('svg') === el\n\t\t\t\t\t\t\t\t\t: fitInsideContainer === el ||\n\t\t\t\t\t\t\t\t\t  blockEl === el\n\t\t\t\t\t\t)\n\n\t\t\t\t\t\tblocks.map((block) => {\n\t\t\t\t\t\t\tblock.isVisible =\n\t\t\t\t\t\t\t\tisIntersecting &&\n\t\t\t\t\t\t\t\tblock.parallaxBehavior.indexOf(\n\t\t\t\t\t\t\t\t\tgetCurrentScreen({ withTablet: true })\n\t\t\t\t\t\t\t\t) > -1\n\n\t\t\t\t\t\t\tthis.blocks = this.blocks.map((nestedBlock) =>\n\t\t\t\t\t\t\t\tnestedBlock.el === block.el\n\t\t\t\t\t\t\t\t\t? block\n\t\t\t\t\t\t\t\t\t: nestedBlock\n\t\t\t\t\t\t\t)\n\n\t\t\t\t\t\t\tif (!block.isVisible)\n\t\t\t\t\t\t\t\tblock.el.removeAttribute('style')\n\t\t\t\t\t\t})\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t},\n\t\t\t{\n\t\t\t\trootMargin: '450px',\n\t\t\t}\n\t\t)\n\n\t\twindow.addEventListener('resize', () => {\n\t\t\tthis.oldPosY = false\n\t\t\tthis.blocks = this.blocks.map((block) =>\n\t\t\t\tcreateBlock({\n\t\t\t\t\t...block,\n\t\t\t\t\tisVisible:\n\t\t\t\t\t\telementInViewport(\n\t\t\t\t\t\t\tblock.fitInsideContainer\n\t\t\t\t\t\t\t\t? block.fitInsideContainer\n\t\t\t\t\t\t\t\t: block.el\n\t\t\t\t\t\t) &&\n\t\t\t\t\t\tblock.parallaxBehavior.indexOf(\n\t\t\t\t\t\t\tgetCurrentScreen({ withTablet: true })\n\t\t\t\t\t\t) > -1,\n\t\t\t\t})\n\t\t\t)\n\t\t\tthis.animate()\n\t\t})\n\n\t\t// Start the loop\n\t\tthis.update()\n\n\t\t// The loop does nothing if the scrollPosition did not change\n\t\t// so call animate to make sure every element has their transforms\n\t\tthis.animate()\n\t}\n\n\tremoveEl({ el }) {\n\t\tel.removeAttribute('style')\n\t\tthis.blocks = this.blocks.filter(({ el: e }) => e !== el)\n\t}\n\n\taddEl({\n\t\tel,\n\t\tspeed,\n\t\tfitInsideContainer = null,\n\t\tshouldSetHeightToIncrease = true,\n\t\tparallaxBehavior = 'desktop:tablet:mobile',\n\t}) {\n\t\tif (fitInsideContainer) {\n\t\t\tthis.intersectionObserver.observe(fitInsideContainer)\n\t\t} else {\n\t\t\tthis.intersectionObserver.observe(\n\t\t\t\tel.closest('svg') ? el.closest('svg') : el\n\t\t\t)\n\t\t}\n\n\t\tthis.blocks.push(\n\t\t\tcreateBlock({\n\t\t\t\tel,\n\t\t\t\tspeed,\n\t\t\t\tfitInsideContainer,\n\t\t\t\tisVisible:\n\t\t\t\t\telementInViewport(\n\t\t\t\t\t\tfitInsideContainer ? fitInsideContainer : el\n\t\t\t\t\t) &&\n\t\t\t\t\tparallaxBehavior.indexOf(\n\t\t\t\t\t\tgetCurrentScreen({ withTablet: true })\n\t\t\t\t\t) > -1,\n\n\t\t\t\tshouldSetHeightToIncrease,\n\t\t\t\tparallaxBehavior,\n\t\t\t})\n\t\t)\n\t}\n\n\tupdate() {\n\t\tif (!this.oldPosY && this.oldPosY !== 0) {\n\t\t\tthis.animate()\n\t\t}\n\n\t\tif (this.setPosition()) {\n\t\t\tthis.animate()\n\t\t}\n\n\t\trequestAnimationFrame(this.update.bind(this))\n\t}\n\n\tsetPosition() {\n\t\tif (this.blocks.length === 0) return false\n\n\t\tlet old = this.oldPosY\n\t\tthis.oldPosY = pageYOffset\n\n\t\treturn old != pageYOffset\n\t}\n\n\tanimate() {\n\t\tthis.blocks.map((block) => {\n\t\t\tif (!block.isVisible) {\n\t\t\t\tblock.el.removeAttribute('style')\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar percentage =\n\t\t\t\t(pageYOffset - block.top + innerHeight()) /\n\t\t\t\t(block.height + innerHeight())\n\n\t\t\tlet { top, height } = nullifyTransforms(\n\t\t\t\tblock.fitInsideContainer ? block.fitInsideContainer : block.el\n\t\t\t)\n\n\t\t\tif (!height) {\n\t\t\t\theight = (block.fitInsideContainer\n\t\t\t\t\t? block.fitInsideContainer\n\t\t\t\t\t: block.el\n\t\t\t\t).getBoundingClientRect().height\n\t\t\t}\n\n\t\t\tconst newPercentage =\n\t\t\t\t1 -\n\t\t\t\t(top +\n\t\t\t\t\t(block.el.dataset.percentage &&\n\t\t\t\t\tparseInt(block.el.dataset.percentage, 10) === 0\n\t\t\t\t\t\t? 0\n\t\t\t\t\t\t: height / 2)) /\n\t\t\t\t\tinnerHeight()\n\n\t\t\t// Subtracting initialize value, so element stays in same spot as HTML\n\t\t\tvar position =\n\t\t\t\tupdatePosition(\n\t\t\t\t\tblock.fitInsideContainer ? percentage : newPercentage,\n\t\t\t\t\tblock.speed\n\t\t\t\t) -\n\t\t\t\tupdatePosition(\n\t\t\t\t\tblock.el.dataset.percentage\n\t\t\t\t\t\t? parseInt(block.el.dataset.percentage, 10)\n\t\t\t\t\t\t: 0.5,\n\t\t\t\t\tblock.speed\n\t\t\t\t)\n\n\t\t\t// Move that element\n\t\t\tblock.el.style.transform = `translate3d(0, ${position}px, 0)`\n\t\t})\n\t}\n}\n","import { Rellax } from './rellax'\nimport { onDocumentLoaded } from '../../helpers'\n\nexport let rel = new Rellax()\n\n/**\n * TODO: maybe implement code splitting for parallax elements.\n * It will speed the up the process a lot.\n *\n * Maybe do that at the lib level.\n *\n * We can go about extracting the animate() function into a separated module.\n * This module will be shared among this and the rellax lib code.\n *\n * That way, we can defer execution of the rellax lib. But I guess the code\n * inside rellax.js is very coupled for doing that trick.\n */\n\nexport const mount = (elWithParallax) => {\n\t// Consider here storing the rellax instance onto the section DOM\n\t// element itself. And do that in a non-leaking fashion.\n\t//\n\t// section.rellaxInstance would leak memory\n\tif (\n\t\telWithParallax.ctHasParallax &&\n\t\telWithParallax.querySelector('figure .ct-image-container > img')\n\t) {\n\t\treturn\n\t\t/*\n\t\trel.removeEl({\n\t\t\tel: elWithParallax.querySelector(\n\t\t\t\t'figure .ct-image-container > img'\n\t\t\t),\n\t\t})\n        */\n\t}\n\n\tif (\n\t\telWithParallax.matches('[data-parallax]') &&\n\t\t!elWithParallax.dataset.parallax\n\t) {\n\t\telWithParallax.removeAttribute('data-parallax')\n\t\treturn\n\t}\n\n\telWithParallax.ctHasParallax = true\n\n\tif (elWithParallax.querySelector('figure .ct-image-container > img')) {\n\t\tsetTimeout(() => {\n\t\t\trel.addEl({\n\t\t\t\tel: elWithParallax.querySelector(\n\t\t\t\t\t'figure .ct-image-container > img'\n\t\t\t\t),\n\t\t\t\t// +elWithParallax.dataset.parallaxSpeed,\n\t\t\t\tspeed: -5,\n\t\t\t\tfitInsideContainer: elWithParallax,\n\t\t\t\t...(elWithParallax.dataset.parallax\n\t\t\t\t\t? { parallaxBehavior: elWithParallax.dataset.parallax }\n\t\t\t\t\t: {}),\n\t\t\t})\n\t\t}, 0)\n\t} else {\n\t\trel.addEl({\n\t\t\tel: elWithParallax,\n\t\t\tspeed: +elWithParallax.dataset.parallax,\n\t\t\tshouldSetHeightToIncrease: false,\n\t\t})\n\t}\n}\n"],"names":["module","exports","window","navigator","userAgent","match","ua","indexOf","document","createEvent","e","isIpad","innerHeight","ruler","axis","Math","abs","orientation","dims","w","h","createElement","style","position","height","width","top","documentElement","appendChild","offsetHeight","innerWidth","removeChild","updatePosition","percentage","speed","createBlock","el","fitInsideContainer","isVisible","shouldSetHeightToIncrease","parallaxBehavior","heightWeWantToIncrease","clientHeight","parentNode","nullifyTransforms","pageYOffset","elementInViewport","rect","getBoundingClientRect","bottom","left","right","transformArr","getComputedStyle","transform","split","slice","map","v","parseFloat","length","t","det","rel","constructor","this","blocks","oldPosY","intersectionObserver","IntersectionObserver","entries","target","isIntersecting","intersectionRatio","filter","blockEl","closest","block","getCurrentScreen","withTablet","nestedBlock","removeAttribute","rootMargin","addEventListener","animate","update","removeEl","addEl","observe","push","setPosition","requestAnimationFrame","bind","old","newPercentage","dataset","parseInt","mount","elWithParallax","ctHasParallax","querySelector","matches","parallax","setTimeout"],"sourceRoot":""}